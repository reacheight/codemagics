import { shortMovingCommands, longMovingCommands, switchCommand, attackCommand, findNearestEnemy, hasEnemyAround, isDisabled } from "./commands.js"

export const instructions = {
  ['forest']: {
    [1]: {
      instructions: `Управляй своим персонажем с помощью кода. Пиши код в редакторе справа и запусти его, когда закончишь.\n\n` +
      `Чтобы герой \`hero\` двигался и совершал различные действия, тебе нужно использовать его методы. Метод — это команда, которая говорит герою, что ему нужно сделать, например, атаковать врага или двигаться.` +
      `\n\nИспользуй методы передвижения, чтобы собрать все алмазы.`,
      example: `hero.move_down()\nhero.move_right()`,
      newCommands: shortMovingCommands,
      prevCommands: [],
    },
  
    [2]: {
      instructions: `Молодец! Продолжай в том же духе.\n\nКстати, ты всегда можешь найти список доступных методов под редактором.`,
      example: `hero.move_down()\nhero.move_right()`,
      newCommands: [],
      prevCommands: shortMovingCommands,
    },
  
    [3]: {
      instructions: `Методы могут принимать параметры внутри скобок. Параметры — это дополнительные данные, которые ты даёшь методу, чтобы он знал, как именно выполнить свою задачу.\n\n` +
      `Например, в метод перемещения можно передать число, которое будет означать, сколько шагов должен пройти герой. Это и есть параметр.\n\n` +
      `Используй метод передвижения с параметром, чтобы пройти этот уровень одной строчкой кода. Не забудь, что параметры всегда должны быть внутри скобок!`,
      example: `hero.move_down(3)\nhero.move_right(2)`,
      newCommands: longMovingCommands,
      prevCommands: [],
    },
    [4]: {
      instructions: `Отлично! Теперь используй сразу несколько методов с параметром, чтобы собрать алмазы и дойти до финиша.`,
      example: `hero.move_down(3)\nhero.move_right(2)`,
      newCommands: [],
      prevCommands: longMovingCommands,
    },
    [5]: {
      instructions: `А у тебя здорово получается! Но сможешь ли ты подобрать все алмазы, да ещё и в 10 строчек кода уложиться?`,
      newCommands: [],
      prevCommands: longMovingCommands,
    },
    [6]: {
      instructions: 'Текст в кавычках, например "Мост", называют строкой. Строка — это просто набор букв или слов, который компьютер понимает как текст. Строки тоже можно передавать в методы как параметры внутри скобок.\n\n' +
      'Передай строку с названием рычага в метод `switch`, чтобы переключить его, и посмотри, что произойдет.\n\nИмей в виду: чтобы дотянуться до рычага, герой должен находиться на соседней с ним клетке.',
      example: `hero.switch("Мост")`,
      newCommands: [ switchCommand ],
      prevCommands: longMovingCommands,
    },
    [7]: {
      instructions: 'Если вызвать `switch` с рычагом уже открытого моста, он закроется. Это работает как переключатель: каждый раз мост меняет своё состояние — открывается или закрывается.\n\n' +
      'На этом уровне тебе нужно найти и исправить ошибку в стартовом коде, чтобы герой смог пройти уровень.',
      example: `hero.switch("Мост") # открыть мост
hero.switch("Мост") # закрыть мост
hero.switch("Мост") # снова открыть мост
# и так далее..`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [8]: {
      instructions: 'Отлично, ты уже далеко продвинулся!\n\nКстати, ты можешь крутить колесо мыши, чтобы увеличить или уменьшить уровень.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [9]: {
      instructions: 'Программисты часто оставляют комментарии в своём коде, чтобы сделать его понятнее для себя и других программистов.\n\n' +
      'Ты уже видел их в редакторе справа — это текст, который начинается со знака `#` и не выполняется программой, а служит подсказкой к коду.\n\n' +
      'Чтобы пройти этот уровень тебе надо прочитать комментарии к коду.',
      example: `# в питоне комментарии начинаются с #, они содержат пояснения и подсказки\n\nhero.move_right() # комментарии могут быть на одной строчке с кодом\n\n# а это комментарий\n# сразу на двух строчках подряд`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [10]: {
      instructions: 'Нам преградили дорогу злые рыцари! Придется их проучить.\n\n' +
      'Для этого используй метод `attack`. Передай в него строку с именем врага, чтобы герой его атаковал.\n\n' +
      'Как и с рычагом, герой должен быть рядом с врагом, которого ты хочешь ударить.',
      example: `hero.attack("John")`,
      newCommands: [ attackCommand ],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [11]: {
      instructions: 'Снова эти рыцари! Их слишком много, чтобы сражаться с каждым по отдельности. Подумай, как можно избавиться от всех врагов сразу.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [12]: {
      instructions: 'Используй все выученные методы, чтобы пройти этот уровень!\n\nЕсли вдруг забудешь, как что-то сделать, загляни в список методов под редактором — там есть все команды, которые ты изучил.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [13]: {
      instructions: 'Враги вызвали подкрепление! Этот рыцарь огромный и слишком сильный — герой пока не может его победить.\n\nНо он уже идёт к нам! Если он пересечёт мост, местные жители окажутся в опасности. Как мы можем его остановить, пока не стало слишком поздно?',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [14]: {
      instructions: 'Для хранения данных в программах используют переменные. Переменная — это как коробка, в которую можно положить любую информацию, например, имя врага.\n\n'
      + 'У переменной есть имя, по которому к ней можно обратиться, и значение, которое в ней хранится. Имя каждой переменной должно быть уникальным — нельзя создать две переменные с одинаковым именем.\n\n'
      + 'Чтобы у переменной появилось значение, его нужно присвоить. В Python это делают с помощью знака `=`:',
      example: `# создаем переменную и кладем в нее значение:\n# название = значение\nenemy = "Proggy"\n\n# теперь везде, где мы используем переменную, будет подставляться ее значение:\nhero.attack(enemy) # герой атакует врага с именем Proggy\n\n# обрати внимание, что мы используем переменную без кавычек — это не строка`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [15]: {
      instructions: 'Ты молодец! Теперь ты знаешь, как использовать переменные в коде — это важный навык!\n\n' +
      'На этом уровне нужно будет применять переменные не только для атаки врагов, но и для переключения рычагов.\n\n' +
      'Все переменные для мостов и врагов уже созданы в коде, но кто-то перепутал их значения! Проверь и исправь их, чтобы герой смог пройти первую часть пути. А затем допиши код, чтобы добраться до финиша.',
      example: `enemy = "Proggy"\nhero.attack(enemy)\n\nlever = "Мост"\nhero.switch(lever)`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [16]: {
      instructions: 'Некоторые методы в программировании не только выполняют действия, но и возвращают значения. Метод `find_nearest_enemy` как раз такой — он возвращает имя ближайшего к тебе врага. С его помощью ты можешь победить врагов, которые скрывают свои имена.\n\n'
      + 'Важно: в переменные можно сохранять не только готовые значения, но и результат выполнения методов. Это очень удобно, чтобы потом использовать эти результаты в других командах.\n\n'
      + 'Попробуй сохранить в переменную имя врага, которое вернёт `find_nearest_enemy`, а затем атаковать его:',
      example: `enemy1 = hero.find_nearest_enemy()\nhero.attack(enemy1)\n\nenemy2 = hero.find_nearest_enemy()\nhero.attack(enemy2)`,
      newCommands: [ findNearestEnemy ],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [17]: {
      instructions: 'Отлично! Давай применим все изученные методы для прохождения этого уровня.\n\n'
      + 'Помни, что `find_nearest_enemy()` возвращает самого близкого к тебе врага.',
      newCommands: [ findNearestEnemy ],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [18]: {
      instructions: 'На этом уровне мосты между островками случайные. Это значит, что каждый мост может быть открыт или закрыт, и ты не знаешь заранее, в каком они положении — твой код будет проверяться сразу на нескольких случаях.\n\n'
      + 'Чтобы переключать рычаг моста, только когда он закрыт, тебе понадобятся новый метод `is_disabled("Мост")` и конструкция if (в переводе «если»), с помощью которой можно писать код так, чтобы в разных случаях он работал по-разному.\n\n'
      + 'Посмотри, как это выглядит, и обрати внимание на то, что строчки кода, которые должны выполняться при условии if, должны быть сдвинуты вправо на 4 пробела:',
      example: `hero.move_right(3)            # всегда пройди вправо\nif hero.is_disabled("Мост1"): # если Мост1 закрыт, то\n    hero.switch("Мост1")          # переключи рычаг\nhero.move_down(2)             # всегда пройди вниз`,
      newCommands: [ isDisabled ],
      prevCommands: longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ]),
    },
    [19]: {
      instructions: 'Так держать! Давай закрепим знания. Помни, что мосты на этом уровне случайны — могут быть открыты и закрыты. Проверяй их с помощью конструкции if.',
      example: `hero.move_right(3)            # всегда пройди вправо\nif hero.is_disabled("Мост1"): # если Мост1 закрыт, то\n    hero.switch("Мост1")          # переключи рычаг\nhero.move_down(2)             # всегда пройди вниз`,
      newCommands: [],
      prevCommands: [ isDisabled ].concat(longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ])),
    },
    [20]: {
      instructions: 'Рыцари прячут алмазы на островах, давай заберем их. Но имей в виду: на острове есть алмаз, только если его охраняют! Если дорога открыта — на острове нечего искать.\n\n'
      + 'Тебе надо собрать все доступные алмазы, но при этом ты не должен заходить на остров, если там пусто.',
      newCommands: [],
      prevCommands: [ hasEnemyAround ].concat(longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ])),
    },
    [21]: {
      instructions: 'На этом уровне на каждом островке тебя может поджидать враг, но ты никогда не знаешь точно, есть ли он там — твой код будет проверятся несколько раз на разных случаях. Такие «непостоянные» враги переливаются. Тебе надо дойти до финиша, проверяя каждый островок.\n\nВ этом тебе помогут новый метод `has_enemy_around`, который скажет, есть ли на соседних с твоим героем клетках враг, и конструкция if («если»), с помощью которой можно писать код так, чтобы в разных случаях он работал по-разному.',
      example: `hero.move_right(3)              # всегда пройди вправо\nif hero.has_enemy_around():     # если рядом есть враг, то\n    enemy = hero.find_nearest_enemy() # найди врага\n    hero.attack(enemy)                # и атакуй его\nhero.move_down(2)               # всегда пройди вниз`,
      newCommands: [ hasEnemyAround ],
      prevCommands: longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ]),
    },
    [22]: {
      instructions: 'На этом уровне на каждом островке тебя может поджидать враг, но ты никогда не знаешь точно, есть ли он там — твой код будет проверятся несколько раз на разных случаях. Такие «непостоянные» враги переливаются. Тебе надо дойти до финиша, проверяя каждый островок.\n\nВ этом тебе помогут новый метод `has_enemy_around`, который скажет, есть ли на соседних с твоим героем клетках враг, и конструкция if («если»), с помощью которой можно писать код так, чтобы в разных случаях он работал по-разному.',
      example: `hero.move_right(3)              # всегда пройди вправо\nif hero.has_enemy_around():     # если рядом есть враг, то\n    enemy = hero.find_nearest_enemy() # найди врага\n    hero.attack(enemy)                # и атакуй его\nhero.move_down(2)               # всегда пройди вниз`,
      newCommands: [ hasEnemyAround ],
      prevCommands: longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ]),
    },
  }
}