import { shortMovingCommands, longMovingCommands, switchCommand, attackCommand, findNearestEnemy, hasEnemyAround, isDisabled } from "./commands.js"

export const instructions = {
  ['forest']: {
    [1]: {
      instructions: `Управляй своим персонажем с помощью кода. Пиши код в редакторе справа и запусти его, когда закончишь.\n\n` +
      `Чтобы герой \`hero\` двигался и совершал различные действия, тебе нужно использовать его методы. Метод — это команда, которая говорит герою, что ему нужно сделать, например, атаковать врага или двигаться.` +
      `\n\nИспользуй методы передвижения, чтобы собрать все алмазы.`,
      example: `hero.move_down()\nhero.move_right()`,
      newCommands: shortMovingCommands,
      prevCommands: [],
    },
  
    [2]: {
      instructions: `Молодец! Продолжай в том же духе.\n\nКстати, ты всегда можешь найти список доступных методов под редактором.`,
      example: `hero.move_down()\nhero.move_right()`,
      newCommands: [],
      prevCommands: shortMovingCommands,
    },
  
    [3]: {
      instructions: `Методы могут принимать параметры внутри скобок. Параметры — это дополнительные данные, которые ты даёшь методу, чтобы он знал, как именно выполнить свою задачу.\n\n` +
      `Например, в метод перемещения можно передать число, которое будет означать, сколько шагов должен пройти герой. Это и есть параметр.\n\n` +
      `Используй метод передвижения с параметром, чтобы пройти этот уровень одной строчкой кода. Не забудь, что параметры всегда должны быть внутри скобок!`,
      example: `hero.move_down(3)\nhero.move_right(2)`,
      newCommands: longMovingCommands,
      prevCommands: [],
    },
    [4]: {
      instructions: `Отлично! Теперь используй сразу несколько методов с параметром, чтобы собрать алмазы и дойти до финиша.`,
      example: `hero.move_down(3)\nhero.move_right(2)`,
      newCommands: [],
      prevCommands: longMovingCommands,
    },
    [5]: {
      instructions: `А у тебя здорово получается! Но сможешь ли ты подобрать все алмазы, да ещё и в 10 строчек кода уложиться?`,
      newCommands: [],
      prevCommands: longMovingCommands,
    },
    [6]: {
      instructions: 'Текст в кавычках, например "Мост", называют строкой. Строка — это просто набор букв или слов, который компьютер понимает как текст. Строки тоже можно передавать в методы как параметры внутри скобок.\n\n' +
      'Передай строку с названием рычага в метод `switch`, чтобы переключить его, и посмотри, что произойдет.\n\nИмей в виду: чтобы дотянуться до рычага, герой должен находиться на соседней с ним клетке.',
      example: `hero.switch("Мост")`,
      newCommands: [ switchCommand ],
      prevCommands: longMovingCommands,
    },
    [7]: {
      instructions: 'Если вызвать `switch` с рычагом уже открытого моста, он закроется. Это работает как переключатель: каждый раз мост меняет своё состояние — открывается или закрывается.\n\n' +
      'На этом уровне тебе нужно найти и исправить ошибку в стартовом коде, чтобы герой смог пройти уровень.',
      example: `hero.switch("Мост") # открыть мост
hero.switch("Мост") # закрыть мост
hero.switch("Мост") # снова открыть мост
# и так далее..`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [8]: {
      instructions: 'Отлично, ты уже далеко продвинулся!\n\nКстати, ты можешь крутить колесо мыши, чтобы увеличить или уменьшить уровень.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [9]: {
      instructions: 'Программисты часто оставляют комментарии в своём коде, чтобы сделать его понятнее для себя и других программистов.\n\n' +
      'Ты уже видел их в редакторе справа — это текст, который начинается со знака `#` и не выполняется программой, а служит подсказкой к коду.\n\n' +
      'Чтобы пройти этот уровень тебе надо прочитать комментарии к коду.',
      example: `# в питоне комментарии начинаются с #, они содержат пояснения и подсказки\n\nhero.move_right() # комментарии могут быть на одной строчке с кодом\n\n# а это комментарий\n# сразу на двух строчках подряд`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [10]: {
      instructions: 'Нам преградили дорогу злые рыцари! Придется их проучить.\n\n' +
      'Для этого используй метод `attack`. Передай в него строку с именем врага, чтобы герой его атаковал.\n\n' +
      'Как и с рычагом, герой должен быть рядом с врагом, которого ты хочешь ударить.',
      example: `hero.attack("John")`,
      newCommands: [ attackCommand ],
      prevCommands: longMovingCommands.concat([ switchCommand ]),
    },
    [11]: {
      instructions: 'Снова эти рыцари! Их слишком много, чтобы сражаться с каждым по отдельности. Подумай, как можно избавиться от всех врагов сразу.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [12]: {
      instructions: 'Используй все выученные методы, чтобы пройти этот уровень!\n\nЕсли вдруг забудешь, как что-то сделать, загляни в список методов под редактором — там есть все команды, которые ты изучил.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [13]: {
      instructions: 'Враги вызвали подкрепление! Этот рыцарь огромный и слишком сильный — герой пока не может его победить.\n\nНо он уже идёт к нам! Если он пересечёт мост, местные жители окажутся в опасности. Как мы можем его остановить, пока не стало слишком поздно?',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [14]: {
      instructions: 'Для хранения данных в программах используют переменные. Переменная — это как коробка, в которую можно положить любую информацию, например, имя врага.\n\n'
      + 'У переменной есть имя, по которому к ней можно обратиться, и значение, которое в ней хранится. Имя каждой переменной должно быть уникальным — нельзя создать две переменные с одинаковым именем.\n\n'
      + 'Чтобы у переменной появилось значение, его нужно присвоить. В Python это делают с помощью знака `=`:',
      example: `# создаем переменную и кладем в нее значение:\n# название = значение\nenemy = "Proggy"\n\n# теперь везде, где мы используем переменную, будет подставляться ее значение:\nhero.attack(enemy) # герой атакует врага с именем Proggy\n\n# обрати внимание, что мы используем переменную без кавычек — это не строка`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [15]: {
      instructions: 'Ты молодец! Теперь ты знаешь, как использовать переменные в коде — это важный навык!\n\n' +
      'На этом уровне нужно будет применять переменные не только для атаки врагов, но и для переключения рычагов.\n\n' +
      'Все переменные для мостов и врагов уже созданы в коде, но кто-то перепутал их значения! Проверь и исправь их, чтобы герой смог пройти первую часть пути. А затем допиши код, чтобы добраться до финиша.',
      example: `enemy = "Proggy"\nhero.attack(enemy)\n\nlever = "Мост"\nhero.switch(lever)`,
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [16]: {
      instructions: 'Некоторые методы в программировании не только выполняют действия, но и возвращают значения. Метод `find_nearest_enemy` как раз такой — он возвращает имя ближайшего к тебе врага. С его помощью ты можешь победить врагов, которые скрывают свои имена.\n\n'
      + 'Важно: в переменные можно сохранять не только готовые значения, но и результат выполнения методов. Это очень удобно, чтобы потом использовать эти результаты в других командах.\n\n'
      + 'Попробуй сохранить в переменную имя врага, которое вернёт `find_nearest_enemy`, а затем атаковать его:',
      example: `enemy1 = hero.find_nearest_enemy()\nhero.attack(enemy1)\n\nenemy2 = hero.find_nearest_enemy()\nhero.attack(enemy2)`,
      newCommands: [ findNearestEnemy ],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand ]),
    },
    [17]: {
      instructions: 'Ты уже многое умеешь! Используй все свои знания, чтобы пройти этот уровень.',
      newCommands: [],
      prevCommands: longMovingCommands.concat([ switchCommand, attackCommand, findNearestEnemy ]),
    },
    [18]: {
      instructions: 'Иногда в программе нужно несколько раз повторить одни и те же действия. Чтобы не писать одинаковый код несколько раз, программисты используют циклы.\n\n' +
      'На этом уровне ты научишься использовать бесконечный цикл `while True`, чтобы герой мог выполнять действия снова и снова, пока не достигнет финиша.\n\n' +
      'Обрати внимание на то, что после `while True` нужно поставить двоеточие `:`, а строчки кода внутри цикла должны начинаться с отступа в 4 пробела. Это показывает, что они относятся к циклу и будут выполняться много раз.',
      example: `hero.move_right() # один раз пройти вправо

while True: # бесконечно повторять
    hero.move_left() # пройти влево
    hero.move_up()   # пройти вверх`,
      newCommands: [],
      prevCommands: longMovingCommands,
    },
    [19]: {
      instructions: 'Здорово, правда? А сможешь пройти этот уровень, используя только цикл?',
      newCommands: [],
      prevCommands: longMovingCommands,
    },
    [20]: {
      instructions: 'На этом уровне тебе нужно будет не только передвигаться в цикле, но и атаковать врагов, встретившихся на пути до финиша.\n\n' +
      'Но сначала подбери алмаз на другом острове — напиши код для этого до цикла.',
      newCommands: [],
      prevCommands: [ findNearestEnemy, attackCommand ].concat(longMovingCommands),
    },
    [21]: {
      instructions: 'На этом уровне тебе снова нужно использовать цикл `while True`, но теперь не при каждом повторе цикла тебе будет встречаться враг! Тебе нужно будет проверять это с помощью нового метода `has_enemy_around()`.\n\n' +
      'Метод `has_enemy_around()` проверяет все клетки вокруг героя и говорит, есть ли на какой-то из них враг, или нет.\n\n' +
      'А чтобы выполнять действия только при определённом условии, в программировании используют специальное слово `if` (в переводе с английского — «если»).\n\n' +
      'Обрати внимание: после условия `if` нужно поставить двоеточие `:`, а строчки кода после него должны начинаться с отступа в 4 пробела — прямо как с циклом `while True` — это показывает, какие команды нужно выполнять, если условие верно.\n\n',
      example: `while True: # бесконечно повторять
    hero.move_right(3) # всегда пройти вправо

    if hero.has_enemy_around(): # если рядом враг
        # снова делаем отступ в 4 пробела
        enemy = hero.find_nearest_enemy() # найди врага
        hero.attack(enemy)                # и атакуй
        
    hero.move_down(2) # всегда пройти вниз`,
      newCommands: [ hasEnemyAround ],
      prevCommands: [ findNearestEnemy, attackCommand ].concat(longMovingCommands),
    },
    [22]: {
      instructions: 'Ого, что-то странное творится с мостами! Они то открыты, то закрыты, и каждый раз по-разному. Это потому что мосты на этом уровне случайные — мы не знаем заранее, какие из них будут открыты, а какие закрыты.\n\n'
      + 'Чтобы пройти уровень, тебе нужно проверять каждый мост и открывать его, только если он закрыт. В этом тебе поможет новый метод `is_disabled("Мост")` — он скажет нам, закрыт ли мост с таким названием.\n\n'
      + 'А чтобы выполнять действия только при определённом условии, в программировании используют специальное слово `if` (в переводе с английского — «если»).\n\n'
      + 'Твой код будет проверяться несколько раз с разными комбинациями открытых и закрытых мостов, поэтому он должен работать в любом случае!\n\n'
      + 'Обрати внимание: после условия `if` нужно поставить двоеточие `:`, а строчки кода после него должны начинаться с отступа в 4 пробела — это показывает, какие команды нужно выполнять, если условие верно.\n\n',
      example: `hero.move_right(3)            # всегда пройди вправо
if hero.is_disabled("Мост1"): # если Мост1 закрыт, то
    hero.switch("Мост1")          # переключи рычаг
hero.move_down(2)             # всегда пройди вниз`,
      newCommands: [ isDisabled ],
      prevCommands: longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ]),
    },
    [23]: {
      instructions: 'Так держать! Давай закрепим знания. Помни, что мосты на этом уровне тоже случайные — они могут быть открыты или закрыты. Чтобы тебе было легче их заметить, случайные мосты мерцают (становятся то ярче, то темнее).\n\n'
      + 'Используй конструкцию `if` и метод `is_disabled` для проверки каждого такого моста.\n\n'
      + 'Не забывай про двоеточие после `if` и отступ в 4 пробела для команд внутри условия.',
      example: `hero.move_right(3)            # всегда пройди вправо
if hero.is_disabled("Мост1"): # если Мост1 закрыт, то
    hero.switch("Мост1")          # переключи рычаг
hero.move_down(2)             # всегда пройди вниз`,
      newCommands: [],
      prevCommands: [ isDisabled ].concat(longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ])),
    },
    [24]: {
      instructions: 'Осторожно! В этом лесу затаились случайные враги! Они похожи на случайные мосты — ты не знаешь заранее, поджидает ли тебя враг, или же путь свободен.\n\n' +
      'Чтобы это проверить, тебе нужно использовать конструкцию `if` и новый метод `has_enemy_around`, который скажет тебе, есть ли рядом с тобой враг.\n\n' +
      'Как и со случайными мостами, твой код будет проверяться на разных вариантах уровня, в которых враги могут появляться и исчезать.',
      example: `hero.move_right(3)              # всегда пройди вправо
if hero.has_enemy_around():     # если рядом есть враг, то
    enemy = hero.find_nearest_enemy() # найди врага
    hero.attack(enemy)                # и атакуй его
hero.move_down(2)               # всегда пройди вниз`,
      newCommands: [ hasEnemyAround ],
      prevCommands: longMovingCommands.concat([ findNearestEnemy, attackCommand, isDisabled, switchCommand ]),
    },
    [25]: {
      instructions: 'Этот уровень полон сюрпризов — здесь есть и случайные мосты, и случайные враги!\n\n' +
      'Используй всё, чему ты научился.',
      example: `if hero.is_disabled("Мост1"):    # если мост закрыт
    hero.switch("Мост1")             # открой его

if hero.has_enemy_around():      # если рядом враг
    enemy = hero.find_nearest_enemy() # найди его
    hero.attack(enemy)                # и атакуй`,
      newCommands: [],
      prevCommands: [ hasEnemyAround, isDisabled ].concat(longMovingCommands.concat([ findNearestEnemy, attackCommand, switchCommand ])),
    },
    [26]: {
      instructions: 'На этом уровне на каждом островке тебя может поджидать враг, но ты никогда не знаешь точно, есть ли он там — твой код будет проверятся несколько раз на разных случаях. Такие «непостоянные» враги переливаются. Тебе надо дойти до финиша, проверяя каждый островок.\n\nВ этом тебе помогут новый метод `has_enemy_around`, который скажет, есть ли на соседних с твоим героем клетках враг, и конструкция if («если»), с помощью которой можно писать код так, чтобы в разных случаях он работал по-разному.',
      example: `hero.move_right(3)              # всегда пройди вправо
if hero.has_enemy_around():     # если рядом есть враг, то
    enemy = hero.find_nearest_enemy() # найди врага
    hero.attack(enemy)                # и атакуй его
hero.move_down(2)               # всегда пройди вниз`,
      newCommands: [ hasEnemyAround ],
      prevCommands: longMovingCommands.concat([ findNearestEnemy, switchCommand, attackCommand ]),
    },
  }
}